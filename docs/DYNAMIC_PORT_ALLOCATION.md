# Dynamic Port Allocation System

## Overview

Socrates now supports **dynamic port allocation**, eliminating conflicts when default ports are already in use by other applications. This allows Socrates to run on any available port on your system.

## Problem Solved

Previously, if port 8008 (API) or port 5173 (frontend) were already in use by another application, Socrates would fail to start or experience connection issues.

**Solution:** The system now automatically finds and uses the next available port, with complete frontend-backend communication regardless of which ports are used.

## How It Works

### API Server (Dynamic Port Detection)

1. **Preferred Port Configuration**
   - Default preferred port: `8008`
   - Can be overridden with: `SOCRATES_API_PORT` environment variable

2. **Automatic Port Selection**
   - If preferred port is available → Use it
   - If preferred port is taken → Try sequential ports (8009, 8010, 8011, etc.)
   - Maximum search range: 100 ports

3. **Port Configuration Export**
   - Creates `port-config.json` in current working directory
   - Contains actual port being used
   - Available via `/port-config` API endpoint (for frontend discovery)

### Frontend (Intelligent Port Discovery)

The frontend uses a 4-strategy discovery process:

#### Strategy 1: Direct API Endpoint Query (Recommended)
- Tries `/port-config` endpoint on ports 8008-8020
- **Fastest:** Directly queries the API for its port
- **No file I/O required**

#### Strategy 2: Config File Discovery
- Looks for `port-config.json` in root directory
- Generated by API startup
- Useful for multi-process scenarios

#### Strategy 3: Legacy Support
- Looks for `server-config.json`
- Backward compatible with older deployments

#### Strategy 4: Health Check Fallback
- Pings `/health` endpoint on ports 8008-8020
- **Slowest:** Full health check on each port
- **Fallback for isolated environments**

## Usage

### Running Locally

```bash
# Start API (will auto-detect port)
cd socrates-api
python -m uvicorn src.socrates_api.main:app --host 127.0.0.1 --port 8008

# Output:
# [INFO] Looking for available port starting from 8008...
# [INFO] ======================================================================
# [INFO] SOCRATES API SERVER CONFIGURATION
# [INFO] ======================================================================
# [INFO] Host:           127.0.0.1
# [INFO] Preferred Port: 8008
# [INFO] Actual Port:    8009                    <-- Used 8009 instead
# [INFO] API URL:        http://127.0.0.1:8009
# [INFO] ======================================================================

# In another terminal, start frontend
cd socrates-frontend
npm run dev

# Frontend automatically detects API on port 8009
# [APIClient] Auto-detected API from /port-config endpoint: http://127.0.0.1:8009
```

### Environment Variables

```bash
# API Port Configuration
export SOCRATES_API_PORT=8008           # Default preferred port
export SOCRATES_API_HOST=127.0.0.1      # Bind to localhost

# Frontend Port Configuration
export SOCRATES_FRONTEND_PORT=5173      # Frontend port (if configurable)
```

### Docker/Production

The system works seamlessly in containerized environments:

```dockerfile
# port-config.json is generated and can be mounted/copied
VOLUME ["/app/port-config.json"]

# Configure preferred port via environment
ENV SOCRATES_API_PORT=8008
```

## Port Configuration File Format

**`port-config.json`** (Auto-generated)

```json
{
  "api": {
    "host": "127.0.0.1",
    "port": 8009,
    "url": "http://127.0.0.1:8009"
  },
  "frontend": {
    "host": "127.0.0.1",
    "port": 5173,
    "url": "http://127.0.0.1:5173"
  },
  "info": "Auto-generated port configuration. DO NOT EDIT."
}
```

## API Endpoints

### `/port-config` (GET)

Returns the current port configuration for client discovery.

**Response:**
```json
{
  "api": {
    "host": "127.0.0.1",
    "port": 8009,
    "url": "http://127.0.0.1:8009"
  },
  "frontend": {
    "host": "127.0.0.1",
    "port": 5173,
    "url": "http://127.0.0.1:5173"
  }
}
```

**CORS:** Enabled for all origins (allows frontend to discover port)

## Debugging

### Check Which Port API is Actually Using

```bash
# From API startup logs
grep "Actual Port:" logs/api.log

# Or query the endpoint
curl http://127.0.0.1:8008/port-config  # Try each port
curl http://127.0.0.1:8009/port-config
curl http://127.0.0.1:8010/port-config
```

### Check Frontend Port Detection

Open browser console (F12) and look for:
```
[APIClient] Discovered API from /port-config endpoint: http://127.0.0.1:8009
```

Or if fallback:
```
[APIClient] Auto-detected API on port: 8009
```

### Port Already in Use Error

If you still get "port already in use":

```bash
# Linux/Mac: Find process using port
lsof -i :8008
kill -9 <PID>

# Windows: Find process using port
netstat -ano | findstr :8008
taskkill /PID <PID> /F
```

Then retry with a different preferred port:

```bash
SOCRATES_API_PORT=9000 python -m uvicorn ...
```

## Troubleshooting

### Frontend Can't Find API

1. **Check browser console** for discovery logs
2. **Verify API is running** on reported port:
   ```bash
   curl http://127.0.0.1:8009/health
   ```
3. **Check CORS headers** in API response:
   ```bash
   curl -i http://127.0.0.1:8009/port-config
   ```
4. **Firewall/proxy issues** - Port discovery tries ports 8008-8020

### API Port Discovery Failed

```bash
# Check if ports are available
netstat -ano | findstr "800[0-9]"

# Try different port range
SOCRATES_API_PORT=9000 npm start
```

## Technical Details

### Port Manager Module

**File:** `socrates-api/src/socrates_api/port_manager.py`

Key functions:
- `is_port_available(host, port)` - Check if port is free
- `find_available_port(preferred_port)` - Find next free port
- `export_port_config(api_port, frontend_port)` - Create port-config.json

### Frontend Discovery Logic

**File:** `socrates-frontend/src/api/client.ts`

The `loadServerConfig()` function implements the 4-strategy discovery process and updates `API_BASE_URL` dynamically.

## Future Enhancements

- [ ] Automatic retry with exponential backoff
- [ ] Port range configuration via environment
- [ ] Kubernetes service discovery integration
- [ ] Docker compose port mapping helpers
- [ ] Multi-instance deployment coordination

## Backwards Compatibility

- **Default ports still respected** when available
- **Legacy config files** (server-config.json) still supported
- **Environment variables** override defaults
- **VITE_API_URL** environment variable works as before

## Migration Guide

If upgrading from fixed-port system:

1. **No changes needed** for local development
2. **For Docker deployments:**
   - Port config now exported during startup
   - Consider mounting `port-config.json` volume
   - Update reverse proxy configs if needed
3. **For frontend deployments:**
   - Frontend auto-detects API port
   - No configuration changes required
